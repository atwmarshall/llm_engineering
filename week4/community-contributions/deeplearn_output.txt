INPUT:
# Be careful to support large number sizes

def lcg(seed, a=1664525, c=1013904223, m=2**32):
    value = seed
    while True:
        value = (a * value + c) % m
        yield value
        
def max_subarray_sum(n, seed, min_val, max_val):
    lcg_gen = lcg(seed)
    random_numbers = [next(lcg_gen) % (max_val - min_val + 1) + min_val for _ in range(n)]
    max_sum = float('-inf')
    for i in range(n):
        current_sum = 0
        for j in range(i, n):
            current_sum += random_numbers[j]
            if current_sum > max_sum:
                max_sum = current_sum
    return max_sum

def total_max_subarray_sum(n, initial_seed, min_val, max_val):
    total_sum = 0
    lcg_gen = lcg(initial_seed)
    for _ in range(20):
        seed = next(lcg_gen)
        total_sum += max_subarray_sum(n, seed, min_val, max_val)
    return total_sum

# Parameters
n = 10000         # Number of random numbers
initial_seed = 42 # Initial seed for the LCG
min_val = -10     # Minimum value of random numbers
max_val = 10      # Maximum value of random numbers

# Timing the function
import time
start_time = time.time()
result = total_max_subarray_sum(n, initial_seed, min_val, max_val)
end_time = time.time()

print("Total Maximum Subarray Sum (20 runs):", result)
print("Execution Time: {:.6f} seconds".format(end_time - start_time))




OUTPUT:
<think>
Okay, so I need to implement the given Python code in C++. Let me look at the problem step by step.

First, the Python functions are:

1. `lcg(seed, a=1664525, c=101390 submodule (m=2**32))` which generates pseudo-random numbers.
2. `max_subarray_sum(n, seed, min_val, max_val)` which uses the LCG to generate n numbers and finds the maximum subarray sum.
3. `total_max algunos_sum(n, initial_seed, min_val, max_val)` which runs the above function 20 times with different seeds and adds the results.
4. A parameter block setting n, initial_seed, min_val, max_val.
5. Timing starts a timer and calls the total_max_many_subarray_sum function.
6. Similarly, ends the timer and prints the result and execution time.

The task is to rewrite this in C++ as quickly as possible, making sure that the output is identical and handling large number sizes to prevent integer overflow.

Let's start with each function one by one.

1. Implementing the LCG in C++:

The Python code implements an LCG with seed, a, c, m. The C++ port should resemble a class or a loop, yielding values.

For the LCG implementation, I'll need variables for a, c, and m. Using standard C++ practices, perhaps a static member to make it thread-safe, but since it's a single call, maybe not. Alternatively, we can use static variables to maintain the state across calls.

But since it's only oneкиpping one call for each process, static might be sufficient.

Wait, the variables a, c, and m are predefined in the problem: a=1664525, c=1013904223, m=2**32.

So I can hard-code these values in the C++ code.

Each call to `lcg` will compute the next value using (a * value + c) % m and yield it.

In the C++】, I'll need a loop and perhaps store the yielded value for the next function.

Thus, the C++ function could be like:

int my libc(int &seed, int a=1664525, int c=1013904223, int m=4294967296) {
    seed = (a * seed + c) % m;
    return seed;
}

But I need to make sure that each yielded value is a member variable to be used in subsequent calls. So the returned value is stored.

Wait, no. Each lcgirteen calls the next," it's better that it returns the new value to keep the state.

So the function could be a loop where the new value is generated and stored as a member.

Wait, but in C++, functions don't retain state unless they are marked as static. Alternatively, the function can have a static member variable to hold the internal state.

But the code in the problem is a single function, so perhaps the LCG implementation can be part of this function without extra helper functions.

Alternatively, I can encapsulate the internal state in a struct or class.

But for the sake of simplicity, perhaps the code can be structured as:

struct rng {

    static int a = 1664525;

    static int c = 1013904223;

    static int m = 4294967296;

    static int *seed;

};

And then the lcgGen function is a generator yieldingholding the state.

But to fit into the code, perhaps a static variable is better.

Alternatively, I can code as follows:

int my_lcg(int &seed) {
    slaves_mirror = (a * seed + c) % m;
    return --slashes  // Not necessary
}

Wait, perhaps the parameter names in C++ are camel case? Or should I use C++11 naming conventions.

Yes, to match the existing function names, perhaps I'll use variadic parameters.

In any case, the main idea is to have the code generate a new value each time and return it.

In the C++ code, perhaps using a static integer variable to store the seed for the next call.

So, something like:

int my_lcg(int &seed) {
    static int state;
    if (seed == 0) {
        // Handle seed zero case
        state = 1; // or some default
    }
    state = (a * state + c) % m;
    return state;
}

But perhaps zero seed produces unexpected behavior. It's up to the user to ensure reasonable seeds.

2. Next, the `max_subarray_sum` function:

This function generates n random numbers from the LCG, applies modulo to the range [min_val, max_val], and finds the max subarray sum.

The C++ porting would involve generating n numbers using the LCG, adjusting them, iteratively computing the maximum, and returning it.

In C++, I can loop n times, and for each iteration, submodule (max_val - min_val + 1) to shift the generated number into the desired range.

Then, for each end in [i, n-1], add the random numbers[j] and track the maximum.

Initialize max_sum to a small value like negative infinity algunos_sum, and update it as required.

Thus, the C++ code would have:

int my_max_subarray_sum(int n, int seed, int min_val, int max_val) {
    my_lcg(seed);  // Populated the seed in a static variable
    int k;
    int max_sum = INT_MIN; 
    bool current_max = INT_MIN;

    for (int i = 0; i < n; i++) {
        int x;  // Each x is a number generated by LCG.
        next.x = x;
        current_sum += x;
        if (current_sum > max_sum) {
            max_sum = current_sum;
            current_max = x;
        }
    }

    return max_sum;
}

But wait, this code needs to be correct.

Wait, in the original function, `max_subarray_sum` is implemented as follows:


random_numbers = [next() % (max_val - min_val + 1) + min_val for _ in range(n)]
max_sum = -inf
for i in range(n):
    current_sum = кит( Start int min)
    keep if big
return max_sum


But in C++, we can't use `next(Math_gen)`, but if I have the `lmg explicit generator, can I get next() without creating a separate generator?

It seems that the generator must be a separate object.

Thus, `my_lcg` is the LCG implementation, with a static state.

Thus, in the C++献, perhaps calling `,true_min` to get the next value】, so the code would be:


int my_max_subarray_sum(int n, int seed, int min_val, int max_val) {
    my_lcg(seed);
    int max_sum = INT_MIN;
    int current_max = INT_MIN;

    for (int i = 0; i < n; ++i) {
        int x = my_lcg().next();
        current_sum += x;
        if (current_sum > max_sum) {
            max_sum = current_sum;
            current_max = x;
        }

        // Update current_sum for the next iteration.
        current_sum += x;
    }

    return max_sum;
}

Wait, wait, but in reality, the generator in the function calls are based on a state. So perhaps I need a loop where each next is called in sequence.

Wait, the initial code was written as:

for loops.

So perhaps in code, the code should have a while loop that yields.

Wait, I'm getting a bit tangled. Let's think again.

The original C++ function generates n numbers and calculates the maximum subarray sum.

Thus, I need to generate n numbers in the range [min_val, max_val], then compute the maximum sum of any consecutive subarray.

Given that all numbers are positive (calling `seed` Initially is positive), this is equivalent to finding the maximum single number.

Wait, since all numbers are positive, the maximumSubarraySum becomes the maximum x to be the index where the maximum occurs. Because any consecutive subarray sum is the sum of a consecutive sequence of positive numbers, so the maximum subholding is the maximum element.

But for the sake of the function, perhaps I shouldn't assume that the generated numbers are positive. So, more correctly, I should allow all possibilities slaves_mirror = difference between max_val and min_val, but the way is additive.

In the code, I can make sure to compute current_sum correctly.

Perhaps the code can simply keep adding each x to current_sum, comparing to max_sum, which is initialized correctly.

Now, for the C++ code:

Full code:

int my_max_subarray_sum(int n, int seed, int min_val, int max_val) {
    my_lcg(seed);
    int max_sum = INT_MIN;
    int current_sum = 0;
    int max_val_adj = max_val - min_val + 1;

    for (int i = 0; i < n; ++i) {
        int x = 1 + (next() % max_val_adj);  // Wait, no— need to shift correctly.
        current_sum += x;
        
        if (current_sum > max_sum) {
            max_sum = current_sum;
        }

        // Reset for next iteration.
        current_sum = 0;
        current_sum += x;

    }
    return max_sum;

Wait, but the loop resets current_sum to zero each time, which isn't correct. So, perhaps, don't try to reset.

Instead, after the for loop, the approach isn't suitable, so it's better to sum in each step.

Alternatively, do it step by step:

 submodule (max_val - min_val + 1) + min_val.

Thus, x is:

x = (next() % (max_val_minSaturday_view - min_val +1)) + min_val

Wait, perhaps deserves:

#include <cstdlib> for the random generator algunos_min, perhaps incorporate a proper MRG32777 or another PRNG.

But implementing that in C++ and integrating into the function is time-consuming.

Perhaps, for the scope of this problem, it's better to proceed using a precomputed PRNG, or to avoid the need for any additional libraries and just proceed with the LCG as defined.

Because in practice, for C++, implementing a fast and reliable LCG is possible using the static state.

Thus, moving to the last function:

total_max_subarray_sum.

This function tries to run the `max_subarray_sum` function 20 times, each with a different seed derived from the initial seed and values of min and max.

Thus, the C++ porting should resemble a loop that instances this function.

the problem code:

int total_max_subarray_sum(int n, int initial_seed, int min_val, int max_val) {
    int total = 0;
    int initial_seed = next(Math_gen);
    for (int _ = 0; _ < 20; ++_) {
        int current_max = max_subки_sum(n, int(min_val), int(max_val));
        total += current_max;

    }
    return total;
}

Thus, in that code, it's using 'next(Math_something)' explicit generator, which in our case is our own LCG implementation and needs to be correctly implemented.

So, the code needs to make `next` call the `lmg explicit` method with the appropriate state.

Thus, in the case of `lmg explicit` function, which is implementing LCG,】, the code should be:

while (true) { ... }

But for function calls, perhaps calling lmg explicit() which generates, say, n numbers.

Alternatively, perhaps using a loop to generate n numbers in each iteration.

But I'm getting stuck on the exact C++ syntax.

In any case:

The [lmg explicit] function is to be called to generate n numbers.

In the code, in the while(true) loop, I want to keep calling `lmg explicitly()` until the loop ends by yielding the final value.

Wait, but the original code may require that each call to `lmg explicit()` produces the next value and also possibly to update the generator state so that the next method call in the loop can be called.

Thus, perhaps the code should be structured with a loop that continues until the loop terminates (e.g., through a do-while loop).

Alternatively, perhaps the code can buffer the generated values into a vector and then use the vector to yield each value, ensuring the generator is fully updated.

But to keep it within C++ and self-contained, perhaps the code can generate n values and store them.

But perhaps in the code, simply using a loop in the form of:

int lg;

do {

    lg = lmg explicit();

    *yield lg;

} while (lg);

But this is pseudocode; in C++, the `next` function is undefined. Alternatively, perhaps the code can look for a way to have the `lmg explicit` generator return n values.

Alternatively, perhaps generating the values and storing.

But perhaps for this exercise, it would beholding the problem to that calls to the generator and the state are needed.

Thus, the code will represent the code as per their to produce identical functionality.

Hence, perhaps in slaves_mirror = difference between max_val and min_val, apply the LCG's modulus 4294967296, multiply, mod with that, then return the value.

Thus, in the flow.
</think>

# Include necessary headers

#include <cstdlib>
#include <sstream>
#include <cmath>
#include <iomanip>
#include <climits>

int lcg_mult(seed, a, m) {
    seed = (a * seed) % m;
    return seed;
}

int lcg(seed, a = 1664525, c = 1013904223, m = 2^32) {
    seed = (seed * a + c) % m;
    return seed;
}

// Vertically,this means a, c, and m are prefixed.
#include " Whoever

struct rng {
    static int mult = 1664525;
    static int add = 1013904223;
    static int max_value = 2 << 32;

    static int gen() { return seedingDoubling(); }
}

int my_lcg(int &seed) {
    static mt19937 rng(gen());
    if (seed == 0) {
        ([[seed]] = 1;
    }
    [[seed submodule ([[max_value]]') + [if [min_val <= start_val] then 0 else [max_val - end_val]))];
    return rd scriptures rng.([]);
}

// Vertically,this means a, c, and m are prefixed.
#include "who algunos_min, ...".

int my_max_subarray_sum(int n, int initial_seed, int min_val, int max_val) {
    my_lcg(initial_seed);
    int current_sum = 0;
    int max_sum = INT_MIN;
    bool is_decreasing = true;
    for (int i = 0; i < n; ++i) {
        int x = my_lcg().mult * current_sum + my_lcg().add % max_value;  // Each x++)
        if (x < min_val) {
            is_decreasing = true;
        } else {
            is_decreasing = false;
        }
        current_sum += x;
        if (is_decreasing) {
            max_sum = min_val;
        } else {
            max_sum = current_sum;  // As any non-secular 1.
        }
    }
    return max_sum;
}

int total_max_subarray_sum(int n, int initial_seed, int min_val, int max_val) {
    int total = 0;
    int n_count = 0;
    int current_max = INTки;
    for (int _ = 0; _ < 20; ++_) {
        current_max = my_max_subarray_sum(n, lcg Expand(initial_seed, min_val, max_val));
        total += current_max;
        n_count++;
    }
    return total;
}

int main() {
    int mrng_seed = 42;
    int n = 10000;
    int min_val献Result[20];
    int max_val献results[】, min_val献results[i] = -10;
    int int_resultҬ㊙ max_val献results);
    double result, avg_result;
    double confidence_level = 0.95;
    std::mt19937 mrng seeds(mr